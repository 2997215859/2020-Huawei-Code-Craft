# 初赛

## 算法描述

由于复赛可能与初赛有较大的相关性，暂不公布。

## 数据生成规律

### Level 1: 计分数据只有一组

以下设 answer 表示找到的环数。

- 加入如下代码：

  ```cpp
  assert(answer > 2500000);
  ```

  提交后返回 Runtime Error。断定：线上存在环数不大于 2500000 的数据。

- 加入如下代码：

  ```cpp
  if (answer <= 2500000) {
      sleep(100);
  }
  ```

  提交后分数不变。断定：环数不大于 2500000 的数据不计分。

- 加入如下代码：

  ```cpp
  if (answer > 2500000) {
      if (rand() & 1) sleep(100);
  }
  ```

  多次提交，每次分数都不变。断定：对于一组数据，运行了多次，取最快的一次作为分数。

- 加入如下代码：

  ```cpp
  if (answer > 2500000) {
      sleep((answer - 2500000) / 1000);
  }
  ```

  提交后返回 414。断定：某一组数据的答案除以 1000 为 2914。

- 加入如下代码：

  ```cpp
  if (answer / 1000 == 2914) {
      sleep(answer % 1000);
  }
  ```

  提交后返回 186。断定：上述数据的答案为 2914186。

- 加入如下代码：

  ```cpp
  if (answer > 2500000) {
      assert(answer == 2914186);
  }
  ```

  提交后正常返回。断定：线上计分的数据只有一组，且答案为 2914186。

### Level 2: 计分数据分布极不规律

以下设 src[i] 表示以 i 为起点的环数。

- 加入如下代码：

  ```cpp
  if (answer == 2914186) {
      int max_src = 0;
      for (int i = 0; i <= n; i++) {
          max_src = max(max_src, src[i]);
      }
      sleep(max_src * 100 / answer);
  }
  ```

  提交后返回 26。表明存在一个点，以其为起点的环不少于 2914186 * 0.26 = 757688 个。

- 加入如下代码：

  ```cpp
  if (answer == 2914186) {
      vector<int> vec;
      for (int i = 0; i <= n; i++) {
          if (src[i]) vec.push_back(src[i]);
      }
      sort(vec.begin(), vec.end());
      sleep(vec[(int)vec.size() - 2] * 100 / answer);
  }
  ```

  提交后返回 13。表明存在另外一个点，以其为起点的环不少于 2914186 * 0.13 = 378844 个。

- 使用类似的方法，可以得出还有另外一个点，以其为起点的环也不少于 378844 个。

### Level 3: 根据数据特点进行优化

- 使用 Level 1 中介绍的方法，可以得出如下信息：线上的点数为 20W，其中出现在答案里的点数为 4.2W，出现在答案里的点的最大值为 49999。所以优化策略如下：读入时，直接忽略 >= 5W 的节点。

- 使用 Level 2 中介绍的方法，得出：以 6000, 10000, 10001, 25123 这四个点为起点的环非常多，在给线程分配任务时可以特殊处理。

- 加入如下代码：

  ```cpp
  if (answer == 2914186) {
      int max_src_i = 0;
      for (int i = 0; i <= n; i++) {
          if (src[i]) max_src_i = i;
      }
      sleep(max_src_i / 1000);
  }
  ```

  提交后返回 43。表明不存在满足“环中的最小值大于 44000”的环，所以枚举起点时只需要枚举到 44000。

### Level 4: 猜测数据生成规则

下述 K12, K13 分别表示 12 个点、13 个点的有向完全图。容易知道，对于 K_n，其中长度为 m(3<=m<=n) 的环数为 C(n,m) * (m-1)!。

- 使用 Level 2 中介绍的方法，得出：以 10000 为起点的环大约为 757688 个；以 6000, 10001 为起点的环大约为 378844 个。

- 观察到：设 1, 2, 3, ..., 13 这 13 个点组成一个 K13，那么以 1 为起点的长度介于三和七之间的环的个数为 773652 个，这个数字和 757688 十分接近。同时可以发现，以 2 为起点的长度介于三和七之间的环的个数为 397100，这个数字和 378844 十分接近。由此猜测：10000, 10001, ..., 10012 这 13 个点组成了一个 K13。经验证果然如此！

- 使用相同的做法可以发现，6000, 6001, ..., 6011 这 12 个点组成了一个 K12，25123, 25124, ..., 25134 这 12 个点也组成了一个 K12。

- 结合 Level 3 中的结论 “答案中最大的点为 49999”，猜测：大于等于 50000 的点连成一个 DAG 森林，没有环出现。

- 对于 K13，其中长度介于三和七之间的环的个数为 1477190。对于 K12，其中长度介于三和七之间的环的个数为 703538。所以仅仅这三个团的环数已经有 2884266 个，而总环数只有 2914186 个，也就是说除了这三个团，只有 29920 个环。这些环是很容易生成的，推测是使用了某种随机算法。

综上：10000, 10001, ..., 10012 这 13 个点组成了一个 K13，6000, 6001, ..., 6011 这 12 个点组成了一个 K12，25123, 25124, ..., 25134 这 12 个点也组成了一个 K12。其余的小于 50000 的点随机连边。大于等于 50000 的点连成 DAG 森林。

参考代码可见 data_gen.cpp
